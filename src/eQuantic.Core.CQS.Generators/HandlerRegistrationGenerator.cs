using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace eQuantic.Core.CQS.Generators;

/// <summary>
/// Source generator that creates extension methods for registering CQS handlers
/// </summary>
[Generator]
public class HandlerRegistrationGenerator : IIncrementalGenerator
{
    private const string CommandHandlerInterface = "eQuantic.Core.CQS.Handlers.ICommandHandler";
    private const string QueryHandlerInterface = "eQuantic.Core.CQS.Handlers.IQueryHandler";
    private const string PagedQueryHandlerInterface = "eQuantic.Core.CQS.Handlers.IPagedQueryHandler";
    private const string NotificationHandlerInterface = "eQuantic.Core.CQS.Notifications.INotificationHandler";
    private const string StreamQueryHandlerInterface = "eQuantic.Core.CQS.Streaming.IStreamQueryHandler";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes that implement handler interfaces
        var handlerDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsSyntaxTargetForGeneration(node),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndHandlers = context.CompilationProvider
            .Combine(handlerDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndHandlers,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax { BaseList: not null };
    }

    private static HandlerInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
            return null;

        // Skip abstract classes
        if (classSymbol.IsAbstract)
            return null;

        var handlers = new List<(string InterfaceType, string[] TypeArgs)>();

        foreach (var @interface in classSymbol.AllInterfaces)
        {
            var fullName = @interface.OriginalDefinition.ToDisplayString();

            if (fullName.StartsWith(CommandHandlerInterface) ||
                fullName.StartsWith(QueryHandlerInterface) ||
                fullName.StartsWith(PagedQueryHandlerInterface) ||
                fullName.StartsWith(NotificationHandlerInterface) ||
                fullName.StartsWith(StreamQueryHandlerInterface))
            {
                var typeArgs = @interface.TypeArguments
                    .Select(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                    .ToArray();

                handlers.Add((@interface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), typeArgs));
            }
        }

        if (handlers.Count == 0)
            return null;

        return new HandlerInfo(
            classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            classSymbol.ContainingNamespace.ToDisplayString(),
            handlers);
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<HandlerInfo?> handlers,
        SourceProductionContext context)
    {
        var validHandlers = handlers
            .Where(h => h is not null)
            .Cast<HandlerInfo>()
            .ToList();

        if (validHandlers.Count == 0)
            return;

        var source = GenerateRegistrationExtensions(validHandlers, compilation.AssemblyName ?? "Generated");
        context.AddSource("CQSHandlerRegistration.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateRegistrationExtensions(List<HandlerInfo> handlers, string assemblyName)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
        sb.AppendLine();

        // Create a safe namespace name from the assembly
        var namespaceName = assemblyName.Replace("-", "_").Replace(".", "_");

        sb.AppendLine($"namespace {namespaceName}.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Auto-generated extension methods for registering CQS handlers");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class CQSHandlerRegistrationExtensions");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Registers all discovered CQS handlers from this assembly");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static IServiceCollection AddGeneratedCQSHandlers(this IServiceCollection services)");
        sb.AppendLine("        {");

        foreach (var handler in handlers)
        {
            foreach (var (interfaceType, _) in handler.Interfaces)
            {
                var isNotification = interfaceType.Contains("INotificationHandler");
                var method = isNotification ? "AddTransient" : "TryAddTransient";
                
                sb.AppendLine($"            services.{method}(typeof({interfaceType}), typeof({handler.FullTypeName}));");
            }
        }

        sb.AppendLine("            return services;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private record HandlerInfo(
        string FullTypeName,
        string Namespace,
        List<(string InterfaceType, string[] TypeArgs)> Interfaces);
}
